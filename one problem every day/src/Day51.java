public class Day51 {
    //符号位保持1不变，数值位按位求反，末位加1
    //符号位保持1不变，在数值位中从低位向高位找1，第一个1及其右边的0保持不变，数值位的其余部分求反。
    //如6=0000 0110，-6 = 1111 1001 + 1 = 1111 1010
    //可见最低位的1右边的0，在取反之后就会全部变为1，再加一，进位后，取反获取的1全部进位了，最低位的1又被进位上来了，即最低位的1保持不变。
    //利用补码正数和负数的这一点来快速求解一个数的最低位的1在哪里，即n&-n
    public int[] singleNumbers(int[] nums) {
        int sum=0;
        //得到两个不同的数的异或
        for(int num:nums){
            sum^=num;
        }
        //得到不为0的最低位 两个数在这一位上不同
        int flag=(-sum)&sum;
        int[]ret=new int[2];
        //按照最低位是否相等分组
        for(int num:nums){
            //最低为不等
            if ((flag&num)==0){
                ret[0]^=num;
            }else{
                ret[1]^=num;
            }
        }
        return ret;
    }
}
